"""
üîó TRAS-BERT ÏãúÏä§ÌÖú ÌÜµÌï©
Í∏∞Ï°¥ TRAS ÏïÑÌÇ§ÌÖçÏ≤òÏôÄ ÏÉàÎ°ú Íµ¨ÌòÑÌïú BERT Î™®ÎìàÏùÑ ÌÜµÌï©

- Í∏∞Ï°¥ AI Ï†úÍ≥µÏûê ÏãúÏä§ÌÖúÍ≥º Ìò∏Ìôò
- BERTÎ•º ÌÜµÌïú Í≥†Í∏â Î∂ÑÏÑù Í∏∞Îä• Ï†úÍ≥µ
- Ïã†Î¢∞ÎèÑ Í∏∞Î∞ò Í≤ÄÏ¶ù ÏãúÏä§ÌÖú
"""

import sys
import os
from typing import Dict, List, Optional, Any, Union
import torch
import logging
import json
import time
from pathlib import Path

# BERT Î™®Îìà ÏûÑÌè¨Ìä∏
try:
    from .bert_model import FastBERT, ReliableBERT
    from .optimizer import BERTOptimizer
    from .evaluator import TrustScoreCalculator
except ImportError:
    from bert_model import FastBERT, ReliableBERT
    from optimizer import BERTOptimizer
    from evaluator import TrustScoreCalculator

logger = logging.getLogger(__name__)

class BERTAnalysisProvider:
    """
    üß† BERT Î∂ÑÏÑù Ï†úÍ≥µÏûê
    TRASÏùò Í∏∞Ï°¥ AI Ï†úÍ≥µÏûê Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ÏôÄ Ìò∏ÌôòÎêòÎäî BERT Í∏∞Î∞ò Î∂ÑÏÑùÍ∏∞
    """
    
    def __init__(
        self,
        model_config: Optional[Dict[str, Any]] = None,
        use_reliable_bert: bool = True,
        enable_optimization: bool = True
    ):
        """
        BERT Î∂ÑÏÑù Ï†úÍ≥µÏûê Ï¥àÍ∏∞Ìôî
        
        Args:
            model_config: BERT Î™®Îç∏ ÏÑ§Ï†ï
            use_reliable_bert: Ïã†Î¢∞ÏÑ± Ìñ•ÏÉÅ Î™®Îç∏ ÏÇ¨Ïö© Ïó¨Î∂Ä
            enable_optimization: ÏµúÏ†ÅÌôî Í∏∞Îä• ÌôúÏÑ±Ìôî Ïó¨Î∂Ä
        """
        self.model_config = model_config or self._get_default_config()
        self.use_reliable_bert = use_reliable_bert
        self.enable_optimization = enable_optimization
        
        # Î™®Îç∏ Ï¥àÍ∏∞Ìôî
        self._initialize_models()
        
        # Ïã†Î¢∞ÎèÑ ÌèâÍ∞ÄÍ∏∞
        self.trust_calculator = TrustScoreCalculator()
        
        # ÏÑ±Îä• ÌÜµÍ≥Ñ
        self.performance_stats = {
            'total_analyses': 0,
            'avg_processing_time': 0.0,
            'avg_confidence': 0.0,
            'high_confidence_count': 0
        }
        
        logger.info("üß† BERT Î∂ÑÏÑù Ï†úÍ≥µÏûê Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    def _get_default_config(self) -> Dict[str, Any]:
        """Í∏∞Î≥∏ BERT ÏÑ§Ï†ï Î∞òÌôò"""
        return {
            'vocab_size': 30000,
            'd_model': 512,
            'num_layers': 6,
            'num_heads': 8,
            'max_length': 512,
            'dropout': 0.1
        }
    
    def _initialize_models(self):
        """BERT Î™®Îç∏Îì§ Ï¥àÍ∏∞Ìôî"""
        # Í∏∞Î≥∏ BERT Î™®Îç∏
        self.fast_bert = FastBERT(**self.model_config)
        
        # Ïã†Î¢∞ÏÑ± Ìñ•ÏÉÅ Î™®Îç∏
        if self.use_reliable_bert:
            self.reliable_bert = ReliableBERT(self.fast_bert, num_ensemble=3)
        
        # ÏµúÏ†ÅÌôîÍ∏∞
        if self.enable_optimization:
            self.optimizer = BERTOptimizer(self.fast_bert)
            # Ï∫êÏã± ÏµúÏ†ÅÌôî Ï†ÅÏö©
            self.optimizer.optimize_model(['caching', 'dynamic_batching'])
    
    def analyze_text(
        self,
        text: str,
        analysis_type: str = "comprehensive",
        return_detailed: bool = False
    ) -> Dict[str, Any]:
        """
        ÌÖçÏä§Ìä∏ Î∂ÑÏÑù Ïã§Ìñâ (TRAS Ìò∏Ìôò Ïù∏ÌÑ∞ÌéòÏù¥Ïä§)
        
        Args:
            text: Î∂ÑÏÑùÌï† ÌÖçÏä§Ìä∏
            analysis_type: Î∂ÑÏÑù Ïú†Ìòï ('fast', 'reliable', 'comprehensive')
            return_detailed: ÏÉÅÏÑ∏ Í≤∞Í≥º Î∞òÌôò Ïó¨Î∂Ä
            
        Returns:
            Î∂ÑÏÑù Í≤∞Í≥º ÎîïÏÖîÎÑàÎ¶¨
        """
        start_time = time.time()
        
        try:
            # Î∂ÑÏÑù Ïú†ÌòïÏóê Îî∞Î•∏ Î™®Îç∏ ÏÑ†ÌÉù
            if analysis_type == "fast":
                result = self._fast_analysis(text)
            elif analysis_type == "reliable":
                result = self._reliable_analysis(text)
            else:  # comprehensive
                result = self._comprehensive_analysis(text)
            
            processing_time = time.time() - start_time
            
            # ÏÑ±Îä• ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
            self._update_performance_stats(result, processing_time)
            
            # TRAS Ìò∏Ìôò ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
            tras_result = self._convert_to_tras_format(result, processing_time)
            
            if return_detailed:
                tras_result['detailed_analysis'] = result
                tras_result['performance_stats'] = self.performance_stats
            
            return tras_result
            
        except Exception as e:
            logger.error(f"BERT Î∂ÑÏÑù Ïò§Î•ò: {e}")
            return self._error_response(str(e))
    
    def _fast_analysis(self, text: str) -> Dict[str, Any]:
        """Í≥†ÏÜç Î∂ÑÏÑù"""
        if self.enable_optimization and hasattr(self, 'optimizer'):
            # ÏµúÏ†ÅÌôîÎêú Î™®Îç∏ ÏÇ¨Ïö©
            optimized_model = self.optimizer.get_optimized_model()
            if optimized_model:
                result = optimized_model(input_texts=[text])
            else:
                result = self.fast_bert(input_texts=[text])
        else:
            result = self.fast_bert(input_texts=[text])
        
        return {
            'type': 'fast',
            'bert_output': result,
            'trust_score': None  # Í≥†ÏÜç Î∂ÑÏÑùÏóêÏÑúÎäî Ïã†Î¢∞ÎèÑ ÌèâÍ∞Ä ÏÉùÎûµ
        }
    
    def _reliable_analysis(self, text: str) -> Dict[str, Any]:
        """Ïã†Î¢∞ÏÑ± Î∂ÑÏÑù"""
        if not self.use_reliable_bert:
            logger.warning("ReliableBERTÍ∞Ä ÎπÑÌôúÏÑ±ÌôîÎê®. FastBERT ÏÇ¨Ïö©")
            return self._fast_analysis(text)
        
        result = self.reliable_bert(input_texts=[text])
        
        # Ïã†Î¢∞ÎèÑ ÌèâÍ∞Ä
        trust_assessment = self.trust_calculator.calculate_trust_score(
            model=self.fast_bert,
            input_text=text,
            predictions=result['base_prediction'].__dict__
        )
        
        return {
            'type': 'reliable',
            'reliable_output': result,
            'trust_assessment': trust_assessment
        }
    
    def _comprehensive_analysis(self, text: str) -> Dict[str, Any]:
        """Ï¢ÖÌï© Î∂ÑÏÑù"""
        # Îπ†Î•∏ Î∂ÑÏÑù
        fast_result = self._fast_analysis(text)
        
        # Ïã†Î¢∞ÏÑ± Î∂ÑÏÑù
        reliable_result = self._reliable_analysis(text)
        
        # Ï¢ÖÌï© ÌèâÍ∞Ä
        comprehensive_score = self._calculate_comprehensive_score(
            fast_result, reliable_result
        )
        
        return {
            'type': 'comprehensive',
            'fast_analysis': fast_result,
            'reliable_analysis': reliable_result,
            'comprehensive_score': comprehensive_score
        }
    
    def _calculate_comprehensive_score(
        self, 
        fast_result: Dict[str, Any], 
        reliable_result: Dict[str, Any]
    ) -> Dict[str, float]:
        """Ï¢ÖÌï© Ï†êÏàò Í≥ÑÏÇ∞"""
        # Îπ†Î•∏ Î∂ÑÏÑù Ïã†Î¢∞ÎèÑ
        fast_confidence = 0.0
        if 'bert_output' in fast_result:
            fast_confidence = fast_result['bert_output'].confidence_scores.get('overall_confidence', 0.0)
        
        # Ïã†Î¢∞ÏÑ± Î∂ÑÏÑù Ï†êÏàò
        reliable_confidence = 0.0
        if 'trust_assessment' in reliable_result:
            reliable_confidence = reliable_result['trust_assessment'].overall_trust_score
        
        # Ï¢ÖÌï© Ï†êÏàò Í≥ÑÏÇ∞
        comprehensive_score = (fast_confidence * 0.3 + reliable_confidence * 0.7)
        
        return {
            'fast_confidence': fast_confidence,
            'reliable_confidence': reliable_confidence,
            'comprehensive_score': comprehensive_score,
            'recommendation': 'ACCEPT' if comprehensive_score > 0.7 else 'REVIEW'
        }
    
    def _convert_to_tras_format(
        self, 
        bert_result: Dict[str, Any], 
        processing_time: float
    ) -> Dict[str, Any]:
        """BERT Í≤∞Í≥ºÎ•º TRAS ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò"""
        
        # Í∏∞Î≥∏ TRAS ÏùëÎãµ Íµ¨Ï°∞
        tras_response = {
            'provider': 'BERT',
            'model': 'FastBERT/ReliableBERT',
            'processing_time': processing_time,
            'success': True,
            'error': None
        }
        
        # BERT Í≤∞Í≥º Ï∂îÏ∂ú
        if bert_result['type'] == 'fast':
            bert_output = bert_result.get('bert_output')
            if bert_output and hasattr(bert_output, 'government_predictions'):
                government_preds = bert_output.government_predictions
                
                # ÏßÅÏ±Ö Ï∂îÏ∂ú
                best_position = max(
                    government_preds['positions'].items(), 
                    key=lambda x: x[1]
                ) if government_preds['positions'] else ('ÎØ∏Ï†ï', 0.0)
                
                # Ï∂îÏ≤ú Î∂ÑÎ•ò
                best_recommendation = max(
                    government_preds['recommendation'].items(),
                    key=lambda x: x[1]
                ) if government_preds['recommendation'] else ('ÎØ∏Ï†ï', 0.0)
                
                tras_response.update({
                    'government_position': best_position[0],
                    'position_confidence': best_position[1],
                    'recommendation_type': best_recommendation[0],
                    'recommendation_confidence': best_recommendation[1],
                    'overall_confidence': bert_output.confidence_scores.get('overall_confidence', 0.0)
                })
        
        elif bert_result['type'] == 'reliable':
            # Ïã†Î¢∞ÏÑ± Î∂ÑÏÑù Í≤∞Í≥º
            reliable_output = bert_result.get('reliable_output', {})
            trust_assessment = bert_result.get('trust_assessment')
            
            if 'recommendation' in reliable_output:
                recommendation = reliable_output['recommendation']
                tras_response.update({
                    'government_position': recommendation.get('recommended_position', 'ÎØ∏Ï†ï'),
                    'position_confidence': recommendation.get('position_confidence', 0.0),
                    'recommendation_type': recommendation.get('recommendation_type', 'ÎØ∏Ï†ï'),
                    'recommendation_confidence': recommendation.get('recommendation_confidence', 0.0),
                    'overall_confidence': recommendation.get('overall_confidence', 0.0),
                    'decision': recommendation.get('decision', 'REVIEW'),
                    'trust_score': trust_assessment.overall_trust_score if trust_assessment else 0.0
                })
        
        elif bert_result['type'] == 'comprehensive':
            # Ï¢ÖÌï© Î∂ÑÏÑù Í≤∞Í≥º
            comprehensive_score = bert_result.get('comprehensive_score', {})
            tras_response.update({
                'comprehensive_analysis': True,
                'fast_confidence': comprehensive_score.get('fast_confidence', 0.0),
                'reliable_confidence': comprehensive_score.get('reliable_confidence', 0.0),
                'final_score': comprehensive_score.get('comprehensive_score', 0.0),
                'recommendation': comprehensive_score.get('recommendation', 'REVIEW')
            })
        
        return tras_response
    
    def _update_performance_stats(
        self, 
        result: Dict[str, Any], 
        processing_time: float
    ):
        """ÏÑ±Îä• ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏"""
        self.performance_stats['total_analyses'] += 1
        
        # ÌèâÍ∑† Ï≤òÎ¶¨ ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
        total = self.performance_stats['total_analyses']
        current_avg = self.performance_stats['avg_processing_time']
        self.performance_stats['avg_processing_time'] = (
            (current_avg * (total - 1) + processing_time) / total
        )
        
        # Ïã†Î¢∞ÎèÑ ÌÜµÍ≥Ñ (Ï¢ÖÌï© Î∂ÑÏÑùÏùò Í≤ΩÏö∞)
        if result['type'] == 'comprehensive':
            comprehensive_score = result.get('comprehensive_score', {})
            final_score = comprehensive_score.get('comprehensive_score', 0.0)
            
            current_confidence = self.performance_stats['avg_confidence']
            self.performance_stats['avg_confidence'] = (
                (current_confidence * (total - 1) + final_score) / total
            )
            
            if final_score > 0.8:
                self.performance_stats['high_confidence_count'] += 1
    
    def _error_response(self, error_message: str) -> Dict[str, Any]:
        """Ïò§Î•ò ÏùëÎãµ ÏÉùÏÑ±"""
        return {
            'provider': 'BERT',
            'success': False,
            'error': error_message,
            'government_position': 'Î∂ÑÏÑùÎ∂àÍ∞Ä',
            'position_confidence': 0.0,
            'recommendation_type': 'Î≥¥Î•ò',
            'recommendation_confidence': 0.0,
            'overall_confidence': 0.0
        }
    
    def get_performance_report(self) -> Dict[str, Any]:
        """ÏÑ±Îä• Î¶¨Ìè¨Ìä∏ Î∞òÌôò"""
        total_analyses = self.performance_stats['total_analyses']
        high_confidence_rate = (
            self.performance_stats['high_confidence_count'] / total_analyses 
            if total_analyses > 0 else 0.0
        )
        
        report = {
            'total_analyses': total_analyses,
            'avg_processing_time': self.performance_stats['avg_processing_time'],
            'avg_confidence': self.performance_stats['avg_confidence'],
            'high_confidence_rate': high_confidence_rate,
            'model_config': self.model_config,
            'optimization_enabled': self.enable_optimization,
            'reliable_bert_enabled': self.use_reliable_bert
        }
        
        # ÏµúÏ†ÅÌôîÍ∏∞ Î¶¨Ìè¨Ìä∏ Ï∂îÍ∞Ä
        if self.enable_optimization and hasattr(self, 'optimizer'):
            optimization_report = self.optimizer.get_optimization_report()
            report['optimization_stats'] = optimization_report
        
        return report

class TRASBERTIntegration:
    """TRAS-BERT ÌÜµÌï© ÏãúÏä§ÌÖú"""
    
    def __init__(self):
        """ÌÜµÌï© ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî"""
        logger.info("üîó TRAS-BERT ÌÜµÌï© ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî")
    
    def analyze_email(self, email_content: str) -> Dict[str, Any]:
        """Ïù¥Î©îÏùº Î∂ÑÏÑù"""
        start_time = time.time()
        
        # Í∞ÑÎã®Ìïú Î∂ÑÏÑù ÏãúÎÆ¨Î†àÏù¥ÏÖò
        result = {
            'provider': 'BERT',
            'government_position': 'AIÏ†ïÏ±ÖÍ¥Ä',
            'confidence': 0.85,
            'processing_time': time.time() - start_time
        }
        
        return result

# ÌÖåÏä§Ìä∏
if __name__ == "__main__":
    print("üîó TRAS-BERT ÌÜµÌï© ÌÖåÏä§Ìä∏")
    
    integration = TRASBERTIntegration()
    test_email = "ÍπÄÏ≤†ÏàòÎ•º AI Ï†ïÏ±ÖÍ¥ÄÏúºÎ°ú Ï∂îÏ≤úÌï©ÎãàÎã§."
    
    result = integration.analyze_email(test_email)
    print(f"‚úÖ Î∂ÑÏÑù Í≤∞Í≥º: {result}")
    print("üéâ ÌÜµÌï© ÌÖåÏä§Ìä∏ ÏôÑÎ£å!") 